"""Message-related API endpoints.

This module defines endpoints for the internal messaging system.  Users
can send messages to one another and retrieve their inbox.  All
operations are authenticated via Supabase JWTs and persisted to the
``messages`` table in Supabase.  Each message contains sender and
recipient emails, subject, content, a timestamp and a read flag.
"""

from __future__ import annotations

from datetime import datetime
from typing import List

from fastapi import APIRouter, Depends, HTTPException, status
from fastapi.security import HTTPAuthorizationCredentials, HTTPBearer

from app.models import Message
from app.database import get_supabase_client
from app.routes.profile import get_current_user_email


router = APIRouter(tags=["messages"])

# Reuse the HTTPBearer security scheme from the profile routes.  This
# ensures that requests include a bearer token which we validate via
# Supabase.
security = HTTPBearer()


@router.post("/messages", response_model=Message, status_code=201)
async def create_message(
    message: Message,
    from_email: str = Depends(get_current_user_email),
) -> Message:
    """Create a new internal message.

    The authenticated user's email is used as the ``from_email``.  The
    message is inserted into the ``messages`` table in Supabase.  On
    success the persisted message is returned.  A 401 is returned if
    authentication fails.  A 500 is returned if the database insert
    fails.  The ``id`` and ``date`` fields of the incoming message
    are ignored and will be generated by the API.

    Args:
        message: Incoming message payload containing ``to_email``,
            ``subject`` and ``content``.  ``id`` and ``date`` will be
            overwritten.
        from_email: Injected email of the authenticated user.

    Returns:
        Message: The stored message record.
    """
    client = get_supabase_client()
    if client is None:
        raise HTTPException(status_code=500, detail="Supabase client unavailable")
    # Prepare the row to insert.  Use Supabase-generated UUID by omitting id.
    row = {
        "to_email": message.to_email,
        "from_email": from_email,
        "subject": message.subject,
        "content": message.content,
        "date": datetime.utcnow().isoformat(),
        "read": False,
    }
    try:
        response = client.table("messages").insert(row).execute()
    except Exception as exc:
        raise HTTPException(status_code=500, detail=str(exc))
    if not response.data:
        raise HTTPException(status_code=500, detail="Failed to create message")
    data = response.data[0]
    # Convert the Supabase response into a Message model.  Supabase may
    # return additional fields (e.g. id) which will be accepted by
    # Pydantic.
    return Message(**data)


@router.get("/messages", response_model=List[Message])
async def list_messages(
    email: str = Depends(get_current_user_email),
) -> List[Message]:
    """Retrieve messages for the authenticated user.

    Returns all messages where the user is the recipient (``to_email``)
    ordered by date descending.  If Supabase is not configured or
    retrieval fails, a 500 error is returned.

    Args:
        email: Injected email of the authenticated user.

    Returns:
        List[Message]: Messages sent to the authenticated user.
    """
    client = get_supabase_client()
    if client is None:
        raise HTTPException(status_code=500, detail="Supabase client unavailable")
    try:
        response = (
            client.table("messages")
            .select("*")
            .eq("to_email", email)
            .order("date", desc=True)
            .execute()
        )
    except Exception as exc:
        raise HTTPException(status_code=500, detail=str(exc))
    data = response.data or []
    # Map to list of Message objects
    return [Message(**item) for item in data]


@router.put("/messages/{message_id}/read", response_model=Message)
async def mark_message_read(
    message_id: str,
    email: str = Depends(get_current_user_email),
) -> Message:
    """Mark a message as read.

    This endpoint sets the ``read`` flag of the specified message
    record to ``True``.  Only the recipient of the message may mark
    it read.  If the message does not exist or the user is not the
    recipient, a 404 is returned.  Returns the updated message on
    success.

    Args:
        message_id: UUID of the message to mark as read.
        email: Injected email of the authenticated user.

    Returns:
        Message: The updated message record.
    """
    client = get_supabase_client()
    if client is None:
        raise HTTPException(status_code=500, detail="Supabase client unavailable")
    # First fetch the message to verify ownership
    try:
        response = client.table("messages").select("*").eq("id", message_id).single().execute()
    except Exception as exc:
        raise HTTPException(status_code=500, detail=str(exc))
    message_row = response.data
    if not message_row or message_row.get("to_email") != email:
        raise HTTPException(status_code=404, detail="Message not found")
    # Update the read flag
    try:
        update_resp = (
            client.table("messages")
            .update({"read": True})
            .eq("id", message_id)
            .execute()
        )
    except Exception as exc:
        raise HTTPException(status_code=500, detail=str(exc))
    updated = update_resp.data[0] if update_resp.data else message_row
    return Message(**updated)
